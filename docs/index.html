<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Payment Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet" />
  <style>
    body { background-color: #f8f9fa; min-height: 100vh; }
    .header { background-color: #495057; color: white; padding: 2rem 0; }
    .card { box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .list-group-item-sm { padding: 0.5rem 1rem; }
    .table-sm th, .table-sm td { padding: 0.5rem; font-size: 0.9rem; }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark shadow-sm sticky-top">
      <div class="container">
          <div class="row">
              <a class="navbar-brand fw-bold" href="https://geoffschoeman.com">
                  <i class="bi bi-globe"></i> geoffschoeman.com
              </a>
          </div>
      </div>
  </nav>
  <div class="max-w-4xl mx-auto px-4">
      <h1 class="text-4xl font-bold text-center mb-2 text-gray-800">
        Payment Calculator
      </h1>
    </div>

  <div class="container my-5">
    <div id="app"></div>
  </div>

  <!-- React + ReactDOM -->
  <script defer src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script defer src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Babel for JSX -->
  <script defer src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- FileSaver.js for clean export filenames -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Helper: Convert frequency to monthly amount
    function calculateMonthlyAmount(amount, frequency) {
      switch (frequency) {
        case 'weekly':  return parseFloat((amount * 4.333).toFixed(2));
        case 'yearly':  return parseFloat((amount / 12).toFixed(2));
        case 'monthly':
        default:        return parseFloat(amount.toFixed(2));
      }
    }

    // ──────────────────────────────────────────────────────────────
    // New helper: Calculate current required minimum payments in a month
    // ──────────────────────────────────────────────────────────────
    function calculateRequiredMinimums(currentDebts, expenses) {
        const minExpenses = expenses.reduce((sum, e) => sum + calculateMonthlyAmount(e.amount, e.frequency), 0);

        let minDebts = 0;
        currentDebts.forEach(debt => {
            if (debt.balance <= 0.01) return;

            let minPay = parseFloat(debt.monthlyPayment.toFixed(2));

            // Credit card fallback minimum
            if (debt.type === 'card') {
                const ccMin = Math.max(25, parseFloat((debt.balance * 0.03).toFixed(2)));
                minPay = Math.max(minPay, ccMin);
            }

            // Never pay less than interest + tiny bit (avoid infinite loop)
            const monthlyRate = debt.apr / 12 / 100;
            const interest = debt.balance * monthlyRate;
            if (minPay < interest) minPay = parseFloat((interest + 0.01).toFixed(2));

            minDebts += minPay;
        });

        return {
            expenses: parseFloat(minExpenses.toFixed(2)),
            debts: parseFloat(minDebts.toFixed(2)),
            totalRequired: parseFloat((minExpenses + minDebts).toFixed(2))
        };
    }

    // Core avalanche schedule generator (used for summary)
    function generateDebtSchedule(debts, extraPayment, extraPaymentFrequency) {
      let remainingDebts = debts.map(debt => ({
        ...debt,
        balance: parseFloat(debt.principal.toFixed(2)),
        monthlyPayment: parseFloat(debt.payment.toFixed(2))
      }));
      let totalInterest = 0;
      let month = 1;
      const maxMonths = 10000;

      while (remainingDebts.some(d => d.balance > 0.01) && month <= maxMonths) {
        const activeDebts = remainingDebts.filter(d => d.balance > 0.01).sort((a, b) => b.apr - a.apr);

        let extra = 0;
        if (extraPaymentFrequency === 'monthly') extra = parseFloat(extraPayment.toFixed(2));
        else if (extraPaymentFrequency === 'yearly') extra = parseFloat((extraPayment / 12).toFixed(2));
        else if (extraPaymentFrequency === 'one-time' && month === 1) extra = parseFloat(extraPayment.toFixed(2));

        remainingDebts = remainingDebts.map(debt => {
          if (debt.balance <= 0.01) return { ...debt, balance: 0 };

          const monthlyRate = debt.apr / 12 / 100;
          const interest = parseFloat((debt.balance * monthlyRate).toFixed(2));
          totalInterest += interest;

          let payment = Math.max(debt.monthlyPayment, 0.01);

          // Credit card minimum payment logic
          if (debt.type === 'card') {
            const minPayment = Math.max(25, parseFloat((debt.balance * 0.03).toFixed(2)));
            if (payment < interest) payment = Math.max(minPayment, interest + 0.01);
          } else if (payment < interest && extra <= 0) {
            payment = interest + 0.01;
          }

          let extraApplied = 0;
          if (extra > 0 && activeDebts[0]?.name === debt.name) {
            extraApplied = Math.min(extra, debt.balance + interest - payment);
            extra -= extraApplied;
          }

          const totalPayment = payment + extraApplied;
          const principalPaid = Math.min(totalPayment - interest, debt.balance);
          const newBalance = parseFloat((debt.balance - principalPaid).toFixed(2));

          return { ...debt, balance: newBalance };
        });
        month++;
      }
      return { months: month - 1, totalInterest: parseFloat(totalInterest.toFixed(2)) };
    }

    // ──────────────────────────────────────────────────────────────
    // Updated generateSchedule – now with target monthly budget support
    // ──────────────────────────────────────────────────────────────
    function generateSchedule(expenses, debts, targetMonthlyPayment, extraPayment, extraPaymentFrequency, startDate) {
        const useTargetBudget = parseFloat(targetMonthlyPayment) > 0;
        const target = useTargetBudget ? parseFloat(targetMonthlyPayment) : 0;

        let remainingDebts = debts.map(d => ({
            ...d,
            balance: parseFloat(d.principal.toFixed(2)),
            monthlyPayment: parseFloat(d.payment.toFixed(2))
        }));

        const schedule = [];
        let totalInterest = 0;
        let month = 1;
        const maxMonths = 10000;
        const baseDate = startDate ? new Date(startDate) : new Date();

        while (remainingDebts.some(d => d.balance > 0.01) && month <= maxMonths) {
            const activeDebts = remainingDebts
                .filter(d => d.balance > 0.01)
                .sort((a, b) => b.apr - a.apr); // avalanche

            const currentDate = new Date(baseDate);
            currentDate.setMonth(baseDate.getMonth() + month - 1);
            const formattedDate = currentDate.toISOString().split('T')[0];

            const monthData = {
                month,
                date: formattedDate,
                expenses: 0,
                debts: {},
                totalPayment: 0
            };

            // Fixed expenses stay the same every month
            const fixedExpenses = expenses.reduce((sum, e) => {
                const m = calculateMonthlyAmount(e.amount, e.frequency);
                monthData.expenses += m;
                return sum + m;
            }, 0);
            monthData.expenses = parseFloat(monthData.expenses.toFixed(2));

            // Always calculate base available from target (0 if not set)
            let availableForDebts = 0;
            if (useTargetBudget) {
                availableForDebts = target - monthData.expenses;
            }

// Always add the extra payment on top (regardless of target)
            let extraThisMonth = 0;
            if (extraPaymentFrequency === 'monthly') {
                extraThisMonth = parseFloat(extraPayment.toFixed(2));
            } else if (extraPaymentFrequency === 'yearly') {
                extraThisMonth = parseFloat((extraPayment / 12).toFixed(2));
            } else if (extraPaymentFrequency === 'one-time' && month === 1) {
                extraThisMonth = parseFloat(extraPayment.toFixed(2));
            }

            availableForDebts += extraThisMonth;
            availableForDebts = Math.max(0, parseFloat(availableForDebts.toFixed(2)));

            // Calculate current minimum required for debts this month
            const minDebtPayments = {};
            let totalMinDebtThisMonth = 0;

            remainingDebts.forEach(debt => {
                if (debt.balance <= 0.01) {
                    minDebtPayments[debt.name] = 0;
                    return;
                }

                const monthlyRate = debt.apr / 12 / 100;
                const interest = parseFloat((debt.balance * monthlyRate).toFixed(2));
                totalInterest += interest;

                let minPay = Math.max(debt.monthlyPayment, 0.01);

                if (debt.type === 'card') {
                    const ccMin = Math.max(25, parseFloat((debt.balance * 0.03).toFixed(2)));
                    minPay = Math.max(minPay, ccMin);
                }
                if (minPay < interest) minPay = parseFloat((interest + 0.01).toFixed(2));

                minDebtPayments[debt.name] = minPay;
                totalMinDebtThisMonth += minPay;
            });

            // How much extra we can really apply after minimums
            let rollingExtra = Math.max(0, availableForDebts - totalMinDebtThisMonth);

            // Apply payments – first minimums, then avalanche the rest
            remainingDebts = remainingDebts.map(debt => {
                if (debt.balance <= 0.01) {
                    monthData.debts[debt.name] = { payment: "0.00", extra: "0.00", balance: "0.00" };
                    return { ...debt, balance: 0 };
                }

                const monthlyRate = debt.apr / 12 / 100;
                const interest = parseFloat((debt.balance * monthlyRate).toFixed(2));

                const minPay = minDebtPayments[debt.name] || 0;
                let extraThisDebt = 0;

                // Apply rolling extra to highest interest debt first
                if (rollingExtra > 0 && activeDebts[0]?.name === debt.name) {
                    extraThisDebt = Math.min(rollingExtra, debt.balance + interest - minPay);
                    rollingExtra -= extraThisDebt;
                }

                const totalPaymentThisDebt = parseFloat((minPay + extraThisDebt).toFixed(2));
                const principalPaid = Math.min(totalPaymentThisDebt - interest, debt.balance);
                const newBalance = Math.max(0, parseFloat((debt.balance - principalPaid).toFixed(2)));

                monthData.debts[debt.name] = {
                    payment: totalPaymentThisDebt.toFixed(2),
                    extra: extraThisDebt.toFixed(2),
                    balance: newBalance.toFixed(2)
                };

                monthData.totalPayment += totalPaymentThisDebt;

                return { ...debt, balance: newBalance };
            });

            monthData.totalPayment = parseFloat((monthData.totalPayment + monthData.expenses).toFixed(2));
            schedule.push(monthData);
            month++;
        }

        return {
            schedule,
            months: month - 1,
            totalInterest: parseFloat(totalInterest.toFixed(2))
        };
    }

    // ──────────────────────────────────────────────────────────────
    // Summary version using target monthly payment (no full schedule, just totals)
    // ──────────────────────────────────────────────────────────────
    function generateTargetSummary(expenses, debts, targetMonthlyPayment, extraPayment, extraPaymentFrequency) {
        const target = parseFloat(targetMonthlyPayment);
        if (isNaN(target) || target <= 0) return null;

        let remainingDebts = debts.map(d => ({
            ...d,
            balance: parseFloat(d.principal.toFixed(2)),
            monthlyPayment: parseFloat(d.payment.toFixed(2))
        }));

        let totalInterest = 0;
        let month = 1;
        const maxMonths = 10000;

        while (remainingDebts.some(d => d.balance > 0.01) && month <= maxMonths) {
            const activeDebts = remainingDebts
                .filter(d => d.balance > 0.01)
                .sort((a, b) => b.apr - a.apr);

            const monthlyExpenses = expenses.reduce((sum, e) => {
                return sum + calculateMonthlyAmount(e.amount, e.frequency);
            }, 0);

            // Base from target
            let availableForDebts = target - monthlyExpenses;

            // Add extra on top (same logic as in generateSchedule)
            let extraThisMonth = 0;
            if (extraPaymentFrequency === 'monthly') {
                extraThisMonth = parseFloat(extraPayment.toFixed(2));
            } else if (extraPaymentFrequency === 'yearly') {
                extraThisMonth = parseFloat((extraPayment / 12).toFixed(2));
            } else if (extraPaymentFrequency === 'one-time' && month === 1) {
                extraThisMonth = parseFloat(extraPayment.toFixed(2));
            }

            availableForDebts += extraThisMonth;
            availableForDebts = Math.max(0, parseFloat(availableForDebts.toFixed(2)));

            // Calculate minimum debt payments
            let totalMinDebt = 0;
            const minDebtPayments = {};

            remainingDebts.forEach(debt => {
                if (debt.balance <= 0.01) {
                    minDebtPayments[debt.name] = 0;
                    return;
                }

                const monthlyRate = debt.apr / 12 / 100;
                const interest = debt.balance * monthlyRate;
                totalInterest += interest;

                let minPay = Math.max(debt.monthlyPayment, 0.01);
                if (debt.type === 'card') {
                    const ccMin = Math.max(25, (debt.balance * 0.03));
                    minPay = Math.max(minPay, ccMin);
                }
                if (minPay < interest) minPay = interest + 0.01;

                minDebtPayments[debt.name] = minPay;
                totalMinDebt += minPay;
            });

            let rollingExtra = Math.max(0, availableForDebts - totalMinDebt);

            // Update balances (avalanche style)
            remainingDebts = remainingDebts.map(debt => {
                if (debt.balance <= 0.01) return { ...debt, balance: 0 };

                const monthlyRate = debt.apr / 12 / 100;
                const interest = debt.balance * monthlyRate;

                const minPay = minDebtPayments[debt.name] || 0;
                let extraThisDebt = 0;

                if (rollingExtra > 0 && activeDebts[0]?.name === debt.name) {
                    extraThisDebt = Math.min(rollingExtra, debt.balance + interest - minPay);
                    rollingExtra -= extraThisDebt;
                }

                const totalPayment = minPay + extraThisDebt;
                const principalPaid = Math.min(totalPayment - interest, debt.balance);
                const newBalance = Math.max(0, debt.balance - principalPaid);

                return { ...debt, balance: newBalance };
            });

            month++;
        }

        return {
            months: month - 1,
            totalInterest: parseFloat(totalInterest.toFixed(2))
        };
    }

    function App() {
      const [expenses, setExpenses] = useState([]);
      const [debts, setDebts] = useState([]);
      const [startDate, setStartDate] = useState('');
      const [extraPayment, setExtraPayment] = useState(0);
      const [extraPaymentFrequency, setExtraPaymentFrequency] = useState('monthly');
      const [type, setType] = useState('expense');
      const [name, setName] = useState('');
      const [amount, setAmount] = useState('');
      const [frequency, setFrequency] = useState('monthly');
      const [apr, setApr] = useState('');
      const [payment, setPayment] = useState('');
      const [showSchedule, setShowSchedule] = useState(false);
      const [editing, setEditing] = useState(null);
      const fileInputRef = useRef(null);
      const [targetMonthlyPayment, setTargetMonthlyPayment] = useState('');

        useEffect(() => {
            // Initialize all Bootstrap tooltips on the page
            const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
            const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => {
                return new bootstrap.Tooltip(tooltipTriggerEl, {
                    // Optional: customize behavior if needed
                    trigger: 'hover',       // default is hover + focus
                    delay: { show: 300, hide: 100 }  // slight delay for better UX
                });
            });

            // Cleanup: dispose tooltips when component unmounts
            return () => {
                tooltipList.forEach(tooltip => tooltip.dispose());
            };
        }, []);

        // Load from localStorage
        useEffect(() => {
            const saved = localStorage.getItem('financialTrackerData');
            if (saved) {
                const data = JSON.parse(saved);
                setExpenses(data.expenses || []);
                setDebts(data.debts || []);
                setStartDate(data.startDate || new Date().toISOString().split('T')[0]);
                setExtraPayment(data.extraPayment || 0);
                setExtraPaymentFrequency(data.extraPaymentFrequency || 'monthly');
                setTargetMonthlyPayment(data.targetMonthlyPayment || '');
            } else {
                setStartDate(new Date().toISOString().split('T')[0]);
            }
        }, []);

        // Save to localStorage
        useEffect(() => {
            const data = {
                expenses,
                debts,
                startDate,
                extraPayment,
                extraPaymentFrequency,
                targetMonthlyPayment
            };
            localStorage.setItem('financialTrackerData', JSON.stringify(data));
        }, [expenses, debts, startDate, extraPayment, extraPaymentFrequency, targetMonthlyPayment]);

        const exportData = () => {
            const data = {
                expenses,
                debts,
                startDate,
                extraPayment,
                extraPaymentFrequency,
                targetMonthlyPayment   // ← added
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            saveAs(blob, `payment-calculator-${new Date().toISOString().slice(0,10)}.json`);
        };

      const importData = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
          reader.onload = (ev) => {
              try {
                  const data = JSON.parse(ev.target.result);
                  setExpenses(data.expenses || []);
                  setDebts(data.debts || []);
                  setStartDate(data.startDate || new Date().toISOString().split('T')[0]);
                  setExtraPayment(data.extraPayment || 0);
                  setExtraPaymentFrequency(data.extraPaymentFrequency || 'monthly');
                  setTargetMonthlyPayment(data.targetMonthlyPayment || '');   // ← added
                  setEditing(null);
                  resetForm();
                  alert('Data imported successfully!');
              } catch (err) {
                  alert('Invalid JSON file');
              }
          };
        reader.readAsText(file);
      };

      const resetForm = () => {
        setName(''); setAmount(''); setApr(''); setPayment(''); setFrequency('monthly'); setType('expense');
      };

      const addOrUpdateItem = (e) => {
        e.preventDefault();
        if (!name || !amount || parseFloat(amount) <= 0) return;

        if (type === 'expense') {
          const newExpense = { name, amount: parseFloat(amount), frequency };
          if (editing?.type === 'expense') {
            const updated = [...expenses];
            updated[editing.index] = newExpense;
            setExpenses(updated);
          } else {
            setExpenses([...expenses, newExpense]);
          }
        } else {
          if (!apr || !payment || parseFloat(apr) < 0 || parseFloat(payment) <= 0) return;
          const newDebt = {
            type,
            name,
            principal: parseFloat(amount),
            apr: parseFloat(apr),
            payment: parseFloat(payment)
          };
          if (editing?.type === 'debt') {
            const updated = [...debts];
            updated[editing.index] = newDebt;
            setDebts(updated);
          } else {
            setDebts([...debts, newDebt]);
          }
        }
        setEditing(null);
        resetForm();
      };

      const editItem = (itemType, index) => {
        setEditing({ type: itemType, index });
        if (itemType === 'expense') {
          const exp = expenses[index];
          setType('expense');
          setName(exp.name);
          setAmount(exp.amount);
          setFrequency(exp.frequency);
        } else {
          const debt = debts[index];
          setType(debt.type);
          setName(debt.name);
          setAmount(debt.principal);
          setApr(debt.apr);
          setPayment(debt.payment);
        }
      };

      const deleteItem = (itemType, index) => {
        if (itemType === 'expense') setExpenses(expenses.filter((_, i) => i !== index));
        else setDebts(debts.filter((_, i) => i !== index));
        if (editing?.type === itemType && editing.index === index) {
          setEditing(null);
          resetForm();
        }
      };

      const clearAllData = () => {
        if (confirm('Clear all data? This cannot be undone.')) {
          setExpenses([]);
          setDebts([]);
          setExtraPayment(0);
          setExtraPaymentFrequency('monthly');
          setStartDate(new Date().toISOString().split('T')[0]);
          setShowSchedule(false);
          localStorage.removeItem('financialTrackerData');
        }
      };

        const { schedule = [], months = 0, totalInterest = 0 } = showSchedule
            ? generateSchedule(
                expenses,
                debts,
                targetMonthlyPayment,           // string from input
                parseFloat(extraPayment || 0),
                extraPaymentFrequency,
                startDate
            )
            : {};

        const summary = showSchedule && debts.length > 0
            ? (() => {
                // Always calculate the "minimum payments only" case for comparison
                const withoutExtra = generateDebtSchedule(debts, 0, 'monthly');

                let withTargetOrExtra;

                if (parseFloat(targetMonthlyPayment) > 0) {
                    // Use target budget + extra payment on top
                    withTargetOrExtra = generateTargetSummary(
                        expenses,
                        debts,
                        targetMonthlyPayment,
                        extraPayment,           // pass these so extra can be added
                        extraPaymentFrequency
                    );
                } else {
                    // Fallback to old extra payment only
                    withTargetOrExtra = generateDebtSchedule(
                        debts,
                        parseFloat(extraPayment || 0),
                        extraPaymentFrequency
                    );
                }

                if (!withTargetOrExtra) return null;

                const monthsWith = withTargetOrExtra.months;
                const interestWith = withTargetOrExtra.totalInterest;

                return {
                    monthsWithExtra: monthsWith,
                    monthsWithoutExtra: withoutExtra.months,
                    monthsSaved: Math.max(0, withoutExtra.months - monthsWith),
                    interestWithExtra: interestWith,
                    interestWithoutExtra: withoutExtra.totalInterest,
                    interestSaved: Math.max(0, (withoutExtra.totalInterest - interestWith).toFixed(2))
                };
            })()
            : null;

      const allItems = [
        ...expenses.map((e, i) => ({ ...e, type: 'expense', index: i })),
        ...debts.map((d, i) => ({ ...d, type: d.type, index: i }))
      ];

      return (
        <div className="card">
          <div className="card-body">
            {/* Header Buttons */}
            <div className="d-flex justify-content-between align-items-center mb-4">
              <h2 className="h4 mb-0">Financial Tracker</h2>
              <div>
                <button className="btn btn-success btn-sm me-2" onClick={exportData}>
                  <i className="bi bi-download me-1"></i> Export
                </button>
                <button className="btn btn-info btn-sm me-2" onClick={() => fileInputRef.current.click()}>
                  <i className="bi bi-upload me-1"></i> Import
                </button>
                <input type="file" ref={fileInputRef} style={{display:'none'}} accept=".json" onChange={importData} />
                <button className="btn btn-danger btn-sm" onClick={clearAllData}>
                  <i className="bi bi-trash me-1"></i> Clear All
                </button>
              </div>
            </div>

            {/* Start Date */}
            <div className="row mb-4">
              <div className="col-md-4">
                <label className="form-label">Start Date</label>
                <input type="date" className="form-control" value={startDate} onChange={e => setStartDate(e.target.value)} />
              </div>
            </div>

            {/* Add/Edit Form */}
            <h5 className="mb-3">{editing ? 'Edit Item' : 'Add New Item'}</h5>
            <form onSubmit={addOrUpdateItem} className="row g-3 mb-4">
              <div className="col-md-2">
                <select className="form-select" value={type} onChange={e => { setType(e.target.value); resetForm(); setType(e.target.value); }}>
                  <option value="expense">Expense</option>
                  <option value="loan">Loan</option>
                  <option value="card">Credit Card</option>
                </select>
              </div>
              <div className="col-md-3">
                <input type="text" className="form-control" placeholder="Name" value={name} onChange={e => setName(e.target.value)} required />
              </div>
              <div className="col-md-2">
                <input type="number" className="form-control" placeholder={type === 'expense' ? 'Amount' : 'Principal/Balance'} value={amount} onChange={e => setAmount(e.target.value)} step="0.01" required />
              </div>
              {type === 'expense' && (
                <div className="col-md-2">
                  <select className="form-select" value={frequency} onChange={e => setFrequency(e.target.value)}>
                    <option value="weekly">Weekly</option>
                    <option value="monthly">Monthly</option>
                    <option value="yearly">Yearly</option>
                  </select>
                </div>
              )}
              {type !== 'expense' && (
                <>
                  <div className="col-md-2">
                    <input type="number" className="form-control" placeholder="APR (%)" value={apr} onChange={e => setApr(e.target.value)} step="0.01" required />
                  </div>
                  <div className="col-md-2">
                    <input type="number" className="form-control" placeholder="Payment" value={payment} onChange={e => setPayment(e.target.value)} step="0.01" required />
                  </div>
                </>
              )}
              <div className="col-md-1">
                <button type="submit" className="btn btn-primary w-100">{editing ? 'Update' : 'Add'}</button>
              </div>
              {editing && (
                <div className="col-md-1">
                  <button type="button" className="btn btn-secondary w-100" onClick={() => { setEditing(null); resetForm(); }}>Cancel</button>
                </div>
              )}
            </form>

            {/* Items List */}
            <h5 className="mb-3">Current Items</h5>
            {allItems.length === 0 ? (
              <p className="text-muted">No items added yet.</p>
            ) : (
              <ul className="list-group mb-4">
                {allItems.map((item, idx) => (
                  <li key={idx} className="list-group-item d-flex justify-content-between align-items-center">
                    <div className="d-flex align-items-center">
                      <i className={
                        item.type === 'expense' ? 'bi bi-cash-stack text-info me-3' :
                        item.type === 'loan' ? 'bi bi-building text-warning me-3' :
                        'bi bi-credit-card text-danger me-3'
                      }></i>
                      <div>
                        <strong>{item.name}</strong><br />
                        <small className="text-muted">
                          {item.type === 'expense'
                            ? `$${item.amount.toFixed(2)} ${item.frequency}`
                            : `${item.type === 'loan' ? 'Loan' : 'Card'} • $${item.principal?.toFixed(2) || item.amount?.toFixed(2)} @ ${item.apr}% • Payment: $${item.payment.toFixed(2)}`
                          }
                        </small>
                      </div>
                    </div>
                    <div>
                      <button className="btn btn-outline-primary btn-sm me-1" onClick={() => editItem(item.type, item.index)}>
                        <i className="bi bi-pencil"></i>
                      </button>
                      <button className="btn btn-outline-danger btn-sm" onClick={() => deleteItem(item.type, item.index)}>
                        <i className="bi bi-trash"></i>
                      </button>
                    </div>
                  </li>
                ))}
              </ul>
            )}

              {/* Compact single-row inputs */}
              <div className="row g-2 align-items-end mb-4">
                  <div className="col-md-3 col-sm-6">
                      <label
                          className="form-label small"
                          data-bs-toggle="tooltip"
                          data-bs-placement="top"
                          title="Your fixed monthly budget for ALL expenses + debt payments. As debts are paid off, the freed-up money automatically goes toward higher-interest debts."
                      >
                          Target Monthly
                      </label>
                      <input
                          type="number"
                          className="form-control form-control-sm"
                          placeholder="e.g. 2500"
                          value={targetMonthlyPayment}
                          onChange={e => setTargetMonthlyPayment(e.target.value || '')}
                          step="0.01"
                      />
                  </div>

                  <div className="col-md-3 col-sm-6">
                      <label
                          className="form-label small"
                          data-bs-toggle="tooltip"
                          data-bs-placement="top"
                          title="Additional amount added on top of your target every month (or per selected frequency). Great for bonuses, tax refunds, or extra side income."
                      >
                          Extra Payment
                      </label>
                      <input
                          type="number"
                          className="form-control form-control-sm"
                          value={extraPayment}
                          onChange={e => setExtraPayment(parseFloat(e.target.value) || 0)}
                          step="0.01"
                          min="0"
                      />
                  </div>

                  {/* Frequency and button remain the same */}
                  <div className="col-md-2 col-sm-6">
                      <label
                          className="form-label small"
                          data-bs-toggle="tooltip"
                          data-bs-placement="top"
                          title="The frequency of the extra payment being applied."
                      >
                          Frequency
                      </label>
                      <select className="form-select form-select-sm" value={extraPaymentFrequency} onChange={e => setExtraPaymentFrequency(e.target.value)}>
                          <option value="monthly">Monthly</option>
                          <option value="yearly">Yearly</option>
                          <option value="one-time">One-Time</option>
                      </select>
                  </div>

                  <div className="col-md-4 col-sm-6">
                      <button className="btn btn-success w-100 btn-sm mt-md-4" onClick={() => setShowSchedule(!showSchedule)}>
                          {showSchedule ? 'Hide' : 'Show'} Schedule
                      </button>
                  </div>
              </div>


            {/* Schedule & Summary */}
            {showSchedule && schedule.length > 0 && (
              <div className="mt-5">
                <hr />
                {summary && (
                  <div className="row mb-4">
                    <div className="col-lg-5">
                      <div className="card">
                        <div className="card-header bg-primary text-white">
                          <h5 className="mb-0">Repayment Summary</h5>
                        </div>
                        <div className="card-body">
                          {summary.monthsSaved > 0 && (
                            <div className="alert alert-success">
                              You save <strong>{summary.monthsSaved} months</strong> and <strong>${summary.interestSaved}</strong> in interest!
                            </div>
                          )}
                          <table className="table table-sm">
                            <thead>
                              <tr>
                                <th></th>
                                <th>Regular</th>
                                <th>With Extra</th>
                              </tr>
                            </thead>
                            <tbody>
                              <tr>
                                <td>Months</td>
                                <td>{summary.monthsWithoutExtra}</td>
                                <td>{summary.monthsWithExtra}</td>
                              </tr>
                              <tr>
                                <td>Interest</td>
                                <td>${summary.interestWithoutExtra.toFixed(2)}</td>
                                <td>${summary.interestWithExtra.toFixed(2)}</td>
                              </tr>
                            </tbody>
                          </table>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                <h5>Full Payment Schedule</h5>
                <div className="table-responsive">
                  <table className="table table-sm table-striped">
                    <thead className="table-light">
                      <tr>
                        <th>Date</th>
                        <th>Expenses</th>
                        {debts.map(d => <th key={d.name}>{d.name}<br/><small>Payment (Extra)</small></th>)}
                        <th>Total Payment</th>
                      </tr>
                    </thead>
                    <tbody>
                      {schedule.map(row => (
                        <tr key={row.month}>
                          <td>{row.date}</td>
                          <td>${row.expenses}</td>
                          {debts.map(debt => {
                            const d = row.debts[debt.name] || { payment: "0.00", extra: "0.00" };
                            return (
                              <td key={debt.name}>
                                ${d.payment}
                                {parseFloat(d.extra) > 0 && <span className="text-success"> (+${d.extra})</span>}
                              </td>
                            );
                          })}
                          <td><strong>${row.totalPayment.toFixed(2)}</strong></td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('app')).render(<App />);
  </script>
  <footer class="bg-dark text-white py-2 mt-5 sticky-bottom mt-auto">
      <div class="container text-center">
          <p class="mb-0">&copy; 2012 - 2025 geoffschoeman.com</p>
      </div>
  </footer>
</body>
</html>