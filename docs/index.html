<!doctypehtml><html lang="en"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>Advanced Payment Calculator</title><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css"rel="stylesheet"><style>body{background-color:#f8f9fa;min-height:100vh}.header{background-color:#495057;color:#fff;padding:2rem 0}.card{box-shadow:0 4px 12px rgba(0,0,0,.1)}.list-group-item-sm{padding:.5rem 1rem}.table-sm td,.table-sm th{padding:.5rem;font-size:.9rem}</style><header class="header text-center"><div class="container"><h1>Advanced Payment Calculator</h1><p class="lead">Debt Avalanche • Expenses • Extra Payments • Full Schedule</div></header><div class="container my-5"><div id="app"></div></div><script src="https://unpkg.com/react@18/umd/react.production.min.js"></script><script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script><script src="https://unpkg.com/@babel/standalone/babel.min.js"></script><script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script><script type="text/babel">const { useState, useEffect, useRef } = React;

    // Helper: Convert frequency to monthly amount
    function calculateMonthlyAmount(amount, frequency) {
      switch (frequency) {
        case 'weekly':  return parseFloat((amount * 4.333).toFixed(2));
        case 'yearly':  return parseFloat((amount / 12).toFixed(2));
        case 'monthly':
        default:        return parseFloat(amount.toFixed(2));
      }
    }

    // Core avalanche schedule generator (used for summary)
    function generateDebtSchedule(debts, extraPayment, extraPaymentFrequency) {
      let remainingDebts = debts.map(debt => ({
        ...debt,
        balance: parseFloat(debt.principal.toFixed(2)),
        monthlyPayment: parseFloat(debt.payment.toFixed(2))
      }));
      let totalInterest = 0;
      let month = 1;
      const maxMonths = 10000;

      while (remainingDebts.some(d => d.balance > 0.01) && month <= maxMonths) {
        const activeDebts = remainingDebts.filter(d => d.balance > 0.01).sort((a, b) => b.apr - a.apr);

        let extra = 0;
        if (extraPaymentFrequency === 'monthly') extra = parseFloat(extraPayment.toFixed(2));
        else if (extraPaymentFrequency === 'yearly') extra = parseFloat((extraPayment / 12).toFixed(2));
        else if (extraPaymentFrequency === 'one-time' && month === 1) extra = parseFloat(extraPayment.toFixed(2));

        remainingDebts = remainingDebts.map(debt => {
          if (debt.balance <= 0.01) return { ...debt, balance: 0 };

          const monthlyRate = debt.apr / 12 / 100;
          const interest = parseFloat((debt.balance * monthlyRate).toFixed(2));
          totalInterest += interest;

          let payment = Math.max(debt.monthlyPayment, 0.01);

          // Credit card minimum payment logic
          if (debt.type === 'card') {
            const minPayment = Math.max(25, parseFloat((debt.balance * 0.03).toFixed(2)));
            if (payment < interest) payment = Math.max(minPayment, interest + 0.01);
          } else if (payment < interest && extra <= 0) {
            payment = interest + 0.01;
          }

          let extraApplied = 0;
          if (extra > 0 && activeDebts[0]?.name === debt.name) {
            extraApplied = Math.min(extra, debt.balance + interest - payment);
            extra -= extraApplied;
          }

          const totalPayment = payment + extraApplied;
          const principalPaid = Math.min(totalPayment - interest, debt.balance);
          const newBalance = parseFloat((debt.balance - principalPaid).toFixed(2));

          return { ...debt, balance: newBalance };
        });
        month++;
      }
      return { months: month - 1, totalInterest: parseFloat(totalInterest.toFixed(2)) };
    }

    // Full schedule with dates and expenses
    function generateSchedule(expenses, debts, extraPayment, extraPaymentFrequency, startDate) {
      const totalExpenses = expenses.reduce((sum, e) => sum + calculateMonthlyAmount(e.amount, e.frequency), 0);

      let remainingDebts = debts.map(debt => ({
        ...debt,
        balance: parseFloat(debt.principal.toFixed(2)),
        monthlyPayment: parseFloat(debt.payment.toFixed(2))
      }));

      const schedule = [];
      let totalInterest = 0;
      let month = 1;
      const maxMonths = 10000;
      const baseDate = startDate ? new Date(startDate) : new Date();

      while (remainingDebts.some(d => d.balance > 0.01) && month <= maxMonths) {
        const activeDebts = remainingDebts.filter(d => d.balance > 0.01).sort((a, b) => b.apr - a.apr);

        let extra = 0;
        if (extraPaymentFrequency === 'monthly') extra = parseFloat(extraPayment.toFixed(2));
        else if (extraPaymentFrequency === 'yearly') extra = parseFloat((extraPayment / 12).toFixed(2));
        else if (extraPaymentFrequency === 'one-time' && month === 1) extra = parseFloat(extraPayment.toFixed(2));

        const currentDate = new Date(baseDate);
        currentDate.setMonth(baseDate.getMonth() + month - 1);
        const formattedDate = currentDate.toISOString().split('T')[0];

        const monthData = {
          month,
          date: formattedDate,
          expenses: totalExpenses.toFixed(2),
          debts: {},
          totalPayment: parseFloat(totalExpenses.toFixed(2))
        };

        remainingDebts = remainingDebts.map(debt => {
          if (debt.balance <= 0.01) {
            monthData.debts[debt.name] = { payment: "0.00", extra: "0.00", balance: "0.00" };
            return { ...debt, balance: 0 };
          }

          const monthlyRate = debt.apr / 12 / 100;
          const interest = parseFloat((debt.balance * monthlyRate).toFixed(2));
          totalInterest += interest;

          let payment = Math.max(debt.monthlyPayment, 0.01);
          if (payment < interest && extra <= 0) payment = interest + 0.01;

          let extraApplied = 0;
          if (extra > 0 && activeDebts[0]?.name === debt.name) {
            extraApplied = Math.min(extra, debt.balance + interest - payment);
            extra -= extraApplied;
          }

          const totalPayment = parseFloat((payment + extraApplied).toFixed(2));
          const principalPaid = Math.min(totalPayment - interest, debt.balance);
          const newBalance = parseFloat((debt.balance - principalPaid).toFixed(2));

          monthData.debts[debt.name] = {
            payment: totalPayment.toFixed(2),
            extra: extraApplied.toFixed(2),
            balance: newBalance.toFixed(2)
          };
          monthData.totalPayment = parseFloat((monthData.totalPayment + totalPayment).toFixed(2));

          return { ...debt, balance: newBalance };
        });

        schedule.push(monthData);
        month++;
      }

      return { schedule, months: month - 1, totalInterest: parseFloat(totalInterest.toFixed(2)) };
    }

    function App() {
      const [expenses, setExpenses] = useState([]);
      const [debts, setDebts] = useState([]);
      const [startDate, setStartDate] = useState('');
      const [extraPayment, setExtraPayment] = useState(0);
      const [extraPaymentFrequency, setExtraPaymentFrequency] = useState('monthly');
      const [type, setType] = useState('expense');
      const [name, setName] = useState('');
      const [amount, setAmount] = useState('');
      const [frequency, setFrequency] = useState('monthly');
      const [apr, setApr] = useState('');
      const [payment, setPayment] = useState('');
      const [showSchedule, setShowSchedule] = useState(false);
      const [editing, setEditing] = useState(null);
      const fileInputRef = useRef(null);

      // Load from localStorage
      useEffect(() => {
        const saved = localStorage.getItem('financialTrackerData');
        if (saved) {
          const data = JSON.parse(saved);
          setExpenses(data.expenses || []);
          setDebts(data.debts || []);
          setStartDate(data.startDate || new Date().toISOString().split('T')[0]);
          setExtraPayment(data.extraPayment || 0);
          setExtraPaymentFrequency(data.extraPaymentFrequency || 'monthly');
        } else {
          setStartDate(new Date().toISOString().split('T')[0]);
        }
      }, []);

      // Save to localStorage
      useEffect(() => {
        const data = { expenses, debts, startDate, extraPayment, extraPaymentFrequency };
        localStorage.setItem('financialTrackerData', JSON.stringify(data));
      }, [expenses, debts, startDate, extraPayment, extraPaymentFrequency]);

      const exportData = () => {
        const data = { expenses, debts, startDate, extraPayment, extraPaymentFrequency };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        saveAs(blob, `payment-calculator-${new Date().toISOString().slice(0,10)}.json`);
      };

      const importData = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const data = JSON.parse(ev.target.result);
            setExpenses(data.expenses || []);
            setDebts(data.debts || []);
            setStartDate(data.startDate || new Date().toISOString().split('T')[0]);
            setExtraPayment(data.extraPayment || 0);
            setExtraPaymentFrequency(data.extraPaymentFrequency || 'monthly');
            setEditing(null);
            resetForm();
            alert('Data imported successfully!');
          } catch (err) {
            alert('Invalid JSON file');
          }
        };
        reader.readAsText(file);
      };

      const resetForm = () => {
        setName(''); setAmount(''); setApr(''); setPayment(''); setFrequency('monthly'); setType('expense');
      };

      const addOrUpdateItem = (e) => {
        e.preventDefault();
        if (!name || !amount || parseFloat(amount) <= 0) return;

        if (type === 'expense') {
          const newExpense = { name, amount: parseFloat(amount), frequency };
          if (editing?.type === 'expense') {
            const updated = [...expenses];
            updated[editing.index] = newExpense;
            setExpenses(updated);
          } else {
            setExpenses([...expenses, newExpense]);
          }
        } else {
          if (!apr || !payment || parseFloat(apr) < 0 || parseFloat(payment) <= 0) return;
          const newDebt = {
            type,
            name,
            principal: parseFloat(amount),
            apr: parseFloat(apr),
            payment: parseFloat(payment)
          };
          if (editing?.type === 'debt') {
            const updated = [...debts];
            updated[editing.index] = newDebt;
            setDebts(updated);
          } else {
            setDebts([...debts, newDebt]);
          }
        }
        setEditing(null);
        resetForm();
      };

      const editItem = (itemType, index) => {
        setEditing({ type: itemType, index });
        if (itemType === 'expense') {
          const exp = expenses[index];
          setType('expense');
          setName(exp.name);
          setAmount(exp.amount);
          setFrequency(exp.frequency);
        } else {
          const debt = debts[index];
          setType(debt.type);
          setName(debt.name);
          setAmount(debt.principal);
          setApr(debt.apr);
          setPayment(debt.payment);
        }
      };

      const deleteItem = (itemType, index) => {
        if (itemType === 'expense') setExpenses(expenses.filter((_, i) => i !== index));
        else setDebts(debts.filter((_, i) => i !== index));
        if (editing?.type === itemType && editing.index === index) {
          setEditing(null);
          resetForm();
        }
      };

      const clearAllData = () => {
        if (confirm('Clear all data? This cannot be undone.')) {
          setExpenses([]);
          setDebts([]);
          setExtraPayment(0);
          setExtraPaymentFrequency('monthly');
          setStartDate(new Date().toISOString().split('T')[0]);
          setShowSchedule(false);
          localStorage.removeItem('financialTrackerData');
        }
      };

      const { schedule = [], months = 0, totalInterest = 0 } = showSchedule
        ? generateSchedule(expenses, debts, parseFloat(extraPayment || 0), extraPaymentFrequency, startDate)
        : {};

      const summary = showSchedule && debts.length > 0
        ? (() => {
            const withExtra = generateDebtSchedule(debts, parseFloat(extraPayment || 0), extraPaymentFrequency);
            const withoutExtra = generateDebtSchedule(debts, 0, 'monthly');
            return {
              monthsWithExtra: withExtra.months,
              monthsWithoutExtra: withoutExtra.months,
              monthsSaved: Math.max(0, withoutExtra.months - withExtra.months),
              interestWithExtra: withExtra.totalInterest,
              interestWithoutExtra: withoutExtra.totalInterest,
              interestSaved: Math.max(0, (withoutExtra.totalInterest - withExtra.totalInterest).toFixed(2))
            };
          })()
        : null;

      const allItems = [
        ...expenses.map((e, i) => ({ ...e, type: 'expense', index: i })),
        ...debts.map((d, i) => ({ ...d, type: d.type, index: i }))
      ];

      return (
        <div className="card">
          <div className="card-body">
            {/* Header Buttons */}
            <div className="d-flex justify-content-between align-items-center mb-4">
              <h2 className="h4 mb-0">Financial Tracker</h2>
              <div>
                <button className="btn btn-success btn-sm me-2" onClick={exportData}>
                  <i className="bi bi-download me-1"></i> Export
                </button>
                <button className="btn btn-info btn-sm me-2" onClick={() => fileInputRef.current.click()}>
                  <i className="bi bi-upload me-1"></i> Import
                </button>
                <input type="file" ref={fileInputRef} style={{display:'none'}} accept=".json" onChange={importData} />
                <button className="btn btn-danger btn-sm" onClick={clearAllData}>
                  <i className="bi bi-trash me-1"></i> Clear All
                </button>
              </div>
            </div>

            {/* Start Date */}
            <div className="row mb-4">
              <div className="col-md-4">
                <label className="form-label">Start Date</label>
                <input type="date" className="form-control" value={startDate} onChange={e => setStartDate(e.target.value)} />
              </div>
            </div>

            {/* Add/Edit Form */}
            <h5 className="mb-3">{editing ? 'Edit Item' : 'Add New Item'}</h5>
            <form onSubmit={addOrUpdateItem} className="row g-3 mb-4">
              <div className="col-md-2">
                <select className="form-select" value={type} onChange={e => { setType(e.target.value); resetForm(); setType(e.target.value); }}>
                  <option value="expense">Expense</option>
                  <option value="loan">Loan</option>
                  <option value="card">Credit Card</option>
                </select>
              </div>
              <div className="col-md-3">
                <input type="text" className="form-control" placeholder="Name" value={name} onChange={e => setName(e.target.value)} required />
              </div>
              <div className="col-md-2">
                <input type="number" className="form-control" placeholder={type === 'expense' ? 'Amount' : 'Principal/Balance'} value={amount} onChange={e => setAmount(e.target.value)} step="0.01" required />
              </div>
              {type === 'expense' && (
                <div className="col-md-2">
                  <select className="form-select" value={frequency} onChange={e => setFrequency(e.target.value)}>
                    <option value="weekly">Weekly</option>
                    <option value="monthly">Monthly</option>
                    <option value="yearly">Yearly</option>
                  </select>
                </div>
              )}
              {type !== 'expense' && (
                <>
                  <div className="col-md-2">
                    <input type="number" className="form-control" placeholder="APR (%)" value={apr} onChange={e => setApr(e.target.value)} step="0.01" required />
                  </div>
                  <div className="col-md-2">
                    <input type="number" className="form-control" placeholder="Payment" value={payment} onChange={e => setPayment(e.target.value)} step="0.01" required />
                  </div>
                </>
              )}
              <div className="col-md-1">
                <button type="submit" className="btn btn-primary w-100">{editing ? 'Update' : 'Add'}</button>
              </div>
              {editing && (
                <div className="col-md-1">
                  <button type="button" className="btn btn-secondary w-100" onClick={() => { setEditing(null); resetForm(); }}>Cancel</button>
                </div>
              )}
            </form>

            {/* Items List */}
            <h5 className="mb-3">Current Items</h5>
            {allItems.length === 0 ? (
              <p className="text-muted">No items added yet.</p>
            ) : (
              <ul className="list-group mb-4">
                {allItems.map((item, idx) => (
                  <li key={idx} className="list-group-item d-flex justify-content-between align-items-center">
                    <div className="d-flex align-items-center">
                      <i className={
                        item.type === 'expense' ? 'bi bi-cash-stack text-info me-3' :
                        item.type === 'loan' ? 'bi bi-building text-warning me-3' :
                        'bi bi-credit-card text-danger me-3'
                      }></i>
                      <div>
                        <strong>{item.name}</strong><br />
                        <small className="text-muted">
                          {item.type === 'expense'
                            ? `$${item.amount.toFixed(2)} ${item.frequency}`
                            : `${item.type === 'loan' ? 'Loan' : 'Card'} • $${item.principal?.toFixed(2) || item.amount?.toFixed(2)} @ ${item.apr}% • Payment: $${item.payment.toFixed(2)}`
                          }
                        </small>
                      </div>
                    </div>
                    <div>
                      <button className="btn btn-outline-primary btn-sm me-1" onClick={() => editItem(item.type, item.index)}>
                        <i className="bi bi-pencil"></i>
                      </button>
                      <button className="btn btn-outline-danger btn-sm" onClick={() => deleteItem(item.type, item.index)}>
                        <i className="bi bi-trash"></i>
                      </button>
                    </div>
                  </li>
                ))}
              </ul>
            )}

            {/* Extra Payment & Schedule Toggle */}
            <div className="row g-3 align-items-end">
              <div className="col-md-3">
                <label className="form-label">Extra Payment</label>
                <input type="number" className="form-control" value={extraPayment} onChange={e => setExtraPayment(e.target.value || 0)} step="0.01" />
              </div>
              <div className="col-md-3">
                <label className="form-label">Frequency</label>
                <select className="form-select" value={extraPaymentFrequency} onChange={e => setExtraPaymentFrequency(e.target.value)}>
                  <option value="one-time">One-Time</option>
                  <option value="monthly">Monthly</option>
                  <option value="yearly">Yearly</option>
                </select>
              </div>
              <div className="col-md-3">
                <button className="btn btn-success w-100" onClick={() => setShowSchedule(!showSchedule)}>
                  {showSchedule ? 'Hide' : 'Show'} Payment Schedule
                </button>
              </div>
            </div>

            {/* Schedule & Summary */}
            {showSchedule && schedule.length > 0 && (
              <div className="mt-5">
                <hr />
                {summary && (
                  <div className="row mb-4">
                    <div className="col-lg-5">
                      <div className="card">
                        <div className="card-header bg-primary text-white">
                          <h5 className="mb-0">Repayment Summary</h5>
                        </div>
                        <div className="card-body">
                          {extraPayment > 0 && summary.monthsSaved > 0 && (
                            <div className="alert alert-success">
                              You save <strong>{summary.monthsSaved} months</strong> and <strong>${summary.interestSaved}</strong> in interest!
                            </div>
                          )}
                          <table className="table table-sm">
                            <thead>
                              <tr>
                                <th></th>
                                <th>Regular</th>
                                <th>With Extra</th>
                              </tr>
                            </thead>
                            <tbody>
                              <tr>
                                <td>Months</td>
                                <td>{summary.monthsWithoutExtra}</td>
                                <td>{summary.monthsWithExtra}</td>
                              </tr>
                              <tr>
                                <td>Interest</td>
                                <td>${summary.interestWithoutExtra.toFixed(2)}</td>
                                <td>${summary.interestWithExtra.toFixed(2)}</td>
                              </tr>
                            </tbody>
                          </table>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                <h5>Full Payment Schedule</h5>
                <div className="table-responsive">
                  <table className="table table-sm table-striped">
                    <thead className="table-light">
                      <tr>
                        <th>Date</th>
                        <th>Expenses</th>
                        {debts.map(d => <th key={d.name}>{d.name}<br/><small>Payment (Extra)</small></th>)}
                        <th>Total Payment</th>
                      </tr>
                    </thead>
                    <tbody>
                      {schedule.map(row => (
                        <tr key={row.month}>
                          <td>{row.date}</td>
                          <td>${row.expenses}</td>
                          {debts.map(debt => {
                            const d = row.debts[debt.name] || { payment: "0.00", extra: "0.00" };
                            return (
                              <td key={debt.name}>
                                ${d.payment}
                                {parseFloat(d.extra) > 0 && <span className="text-success"> (+${d.extra})</span>}
                              </td>
                            );
                          })}
                          <td><strong>${row.totalPayment.toFixed(2)}</strong></td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('app')).render(<App />);</script>